'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.calculateEquity = calculateEquity;

var _utils = require('./utils');

var _rank = require('./rank');

var _deck2 = require('./deck');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function calculateEquity(hands) {
  var board = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var iterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100000;
  var exhaustive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  var results = hands.map(function (hand) {
    return {
      hand: hand,
      count: 0,
      wins: 0,
      ties: 0,
      handChances: _utils.RANK_NAMES.map(function (name) {
        return { name: name, count: 0 };
      })
    };
  });
  if (board.length === 5) {
    results = analyse(results, board);
  } else if (board.length >= 3) {
    var deck = (0, _deck2.createDeck)(board.concat.apply(board, _toConsumableArray(hands)));
    for (var i = 0; i !== deck.length; i++) {
      if (board.length === 4) {
        results = analyse(results, board.concat(deck[i]));
        continue;
      }
      for (var j = 0; j !== deck.length; j++) {
        if (i >= j) continue;
        results = analyse(results, board.concat([deck[i], deck[j]]));
      }
    }
  } else if (exhaustive) {
    var _deck = (0, _deck2.createDeck)(board.concat.apply(board, _toConsumableArray(hands)));
    for (var a = 0; a !== _deck.length; a++) {
      for (var b = 0; b !== _deck.length; b++) {
        if (a <= b) continue;
        for (var c = 0; c !== _deck.length; c++) {
          if (b <= c) continue;
          for (var d = 0; d !== _deck.length; d++) {
            if (c <= d) continue;
            for (var e = 0; e !== _deck.length; e++) {
              if (d <= e) continue;
              results = analyse(results, [_deck[a], _deck[b], _deck[c], _deck[d], _deck[e]]);
            }
          }
        }
      }
    }
  } else {
    for (var _i = 0; _i !== iterations; _i++) {
      var _ref;

      var randomCards = (0, _deck2.deal)((_ref = []).concat.apply(_ref, _toConsumableArray(hands)), 5 - board.length);
      results = analyse(results, board.concat(randomCards));
    }
  }
  var maxWins = Math.max.apply(Math, _toConsumableArray(results.map(function (hand) {
    return hand.wins;
  })));
  return results.map(function (hand) {
    return _extends({}, hand, {
      favourite: hand.wins === maxWins
    });
  });
}

function analyse(results, board) {
  var ranks = results.map(function (result) {
    if (result.hand.includes('..')) {
      var randomCards = (0, _deck2.deal)(board.concat.apply(board, _toConsumableArray(results.map(function (r) {
        return r.hand;
      }))), 4);
      var hand = result.hand.map(function (card, index) {
        if (card === '..') {
          return randomCards[index];
        }
        return card;
      });
      return (0, _rank.rankHand)(hand.concat(board));
    }
    return (0, _rank.rankHand)(result.hand.concat(board));
  });
  var bestRank = ranks.slice(0).sort().reverse()[0];
  var tie = ranks.filter(function (rank) {
    return rank === bestRank;
  }).length > 1;
  for (var i = 0; i !== results.length; i++) {
    if (ranks[i] === bestRank) {
      if (tie) {
        results[i].ties++;
      } else {
        results[i].wins++;
      }
    }
    results[i].count++;
    results[i].handChances[parseInt(ranks[i][0])].count++;
  }
  return results;
}